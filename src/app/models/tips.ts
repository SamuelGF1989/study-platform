export const consejosProgramacionC: string[] = [
  "Usa comentarios claros para explicar la lógica compleja.",
  "Siempre inicializa tus variables antes de usarlas.",
  "Usa nombres descriptivos para variables y funciones.",
  "Mantén tus funciones cortas y con una sola responsabilidad.",
  "Usa constantes (#define o const) para valores mágicos.",
  "Evita variables globales cuando sea posible.",
  "Controla siempre el valor de retorno de funciones estándar.",
  "Libera toda memoria asignada con malloc usando free.",
  "Usa punteros con cuidado, evitando punteros colgantes.",
  "Valida siempre los punteros antes de usarlos.",
  "Evita el uso de funciones inseguras como gets().",
  "Prefiere fgets() para leer cadenas de texto.",
  "Usa sizeof en vez de valores fijos para asignaciones dinámicas.",
  "Usa const para proteger datos que no deben cambiar.",
  "Evita el uso de magic numbers; usa constantes simbólicas.",
  "Utiliza enum para estados o valores discretos.",
  "Divide el código en archivos .c y .h para modularidad.",
  "Usa macros con precaución; prefiera funciones inline cuando sea posible.",
  "Usa assert() para comprobar condiciones esperadas durante desarrollo.",
  "Controla el tamaño de buffers para evitar desbordamientos.",
  "Siempre comprueba el resultado de operaciones de E/S.",
  "No asumas que cadenas están terminadas en \\0.",
  "Usa funciones seguras para manejar cadenas, como strncpy.",
  "Prefiere operaciones bit a bit para eficiencia cuando corresponda.",
  "Usa typedef para facilitar tipos complejos o punteros.",
  "Usa comentarios para explicar por qué se hace algo, no solo qué.",
  "Usa sangría consistente y clara para mejorar legibilidad.",
  "Evita ciclos infinitos sin condiciones de salida.",
  "Usa estructuras (struct) para agrupar datos relacionados.",
  "Evita la duplicación de código; reutiliza funciones.",
  "Usa herramientas de análisis estático para detectar errores comunes.",
  "Usa variables locales en lugar de globales para evitar efectos colaterales.",
  "Separa la lógica de negocio de la lógica de entrada/salida.",
  "Usa funciones para encapsular tareas repetitivas.",
  "Usa volatile solo cuando sea necesario para variables modificadas externamente.",
  "Documenta las funciones con prototipos claros y comentarios.",
  "Prefiere el uso de switch en vez de múltiples if-else cuando sea adecuado.",
  "Evita usar punteros sin inicializar.",
  "Usa enum para estados en máquinas de estado.",
  "Utiliza memset para inicializar estructuras a cero cuando sea necesario.",
  "Siempre verifica que las asignaciones dinámicas fueron exitosas.",
  "Evita el aliasing de punteros que puede generar comportamientos inesperados.",
  "Usa static para variables y funciones que solo se usen en un archivo.",
  "Usa inline para funciones pequeñas que se llamen muchas veces.",
  "Evita condiciones complicadas en un solo if; sepáralas en funciones.",
  "Usa bibliotecas estándar siempre que sea posible.",
  "Usa herramientas como Valgrind para detectar fugas de memoria.",
  "Evita la aritmética de punteros fuera de límites.",
  "Usa casting explícito cuando conviertas entre tipos incompatibles.",
  "Documenta los efectos secundarios de las funciones.",
  "Usa do-while para menús que deben ejecutarse al menos una vez.",
  "Declara variables lo más cerca posible del uso.",
  "Usa extern para variables compartidas entre archivos.",
  "Usa el preprocesador para código condicional, pero sin abusar.",
  "Usa const en los parámetros de función para indicar que no se modificarán.",
  "Usa funciones recursivas con precaución, asegurando la condición de parada.",
  "Usa punteros a funciones para callbacks y modularidad.",
  "Evita el uso excesivo de punteros a punteros.",
  "Usa funciones para manejo de errores.",
  "No olvides cerrar archivos abiertos con fclose.",
  "Evita la mezcla de estilos de código.",
  "Usa herramientas como clang-format para formato automático.",
  "Evita variables estáticas a menos que sean necesarias.",
  "Siempre que uses arrays, controla que no se acceda fuera de límites.",
  "Usa enum para hacer el código más legible.",
  "Prefiere tipos enteros con tamaño definido (int32_t, uint8_t, etc.).",
  "Usa punteros constantes para proteger datos.",
  "Usa el operador ternario para simplificar código cuando sea claro.",
  "Evita usar goto; solo úsalo para manejo de errores en funciones largas.",
  "Usa union para ahorro de memoria cuando varios datos se excluyen mutuamente.",
  "Usa typedef para facilitar portabilidad entre sistemas.",
  "Mantén el código portable evitando dependencias específicas de plataforma.",
  "Usa printf con cuidado, evitando vulnerabilidades de formato.",
  "Usa snprintf para evitar sobreescritura en buffers.",
  "Usa errno para manejo detallado de errores en llamadas de sistema.",
  "Siempre inicializa punteros a NULL cuando no apuntan a nada.",
  "Evita mezclas de signed y unsigned en comparaciones.",
  "Usa break para salir de ciclos cuando corresponda, evita ciclos innecesarios.",
  "Usa continue con prudencia para mejorar legibilidad en loops.",
  "Documenta claramente la API pública de tus módulos.",
  "Usa macros para logs o debug que puedas activar/desactivar fácilmente.",
  "Usa sizeof para calcular tamaños de arrays en vez de valores hardcoded.",
  "Separa la lógica de prueba y desarrollo de la de producción.",
  "Usa una herramienta de gestión de memoria para proyectos grandes.",
  "Realiza pruebas unitarias para funciones críticas.",
  "Usa macros para definir versiones y opciones de compilación.",
  "Usa typedef struct para definir tipos claros.",
  "Prefiere funciones que devuelvan código de error en vez de abortar el programa.",
  "Usa compiladores con warnings activados y corrígelos siempre.",
  "Usa el estándar C más moderno posible compatible con tu entorno.",
  "Usa nombres de variables en inglés para mantener compatibilidad internacional.",
  "No abuses de punteros aritméticos; puede ser difícil de mantener.",
  "Usa volatile para variables modificadas en interrupciones o hardware.",
  "Usa assert para detectar condiciones imposibles en modo debug.",
  "Mantén la documentación actualizada junto con el código.",
  "Usa estructuras anidadas para modelos de datos complejos.",
  "Usa herramientas de profiling para optimizar rendimiento.",
  "Siempre revisa el resultado de funciones que pueden fallar.",
  "Usa macros para definir constantes con tipos explícitos.",
  "Revisa y mejora continuamente tu código; la calidad siempre puede crecer."
];
